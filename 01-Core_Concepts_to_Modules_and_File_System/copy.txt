/*
Q -> What is NodeJS
Before understanding Node.js, letâ€™s first understand JavaScript (JS).

JavaScript is one of the three core languages that browsers understand:
HTML â†’ provides structure and layout
CSS â†’ provides styling
JavaScript â†’ provides interactivity and functionality

Browsers cannot understand any other programming language directly. Every browser comes with a JavaScript engine that executes JavaScript code.
Chrome â†’ V8 Engine
Firefox â†’ SpiderMonkey
Safari â†’ JavaScriptCore (WebKit)

For example, if you open the browser console and type:

2 + 2
// Output: 4

console.log("Hello")
// Output: Hello

This works because the browserâ€™s JavaScript engine is interpreting and running your JS code.

âŒ Limitation of JavaScript
JavaScript engines are embedded inside browsers, which means originally JavaScript could only run inside a browser, not directly on your computer or server.

âœ… Enter Node.js
The breakthrough happened when Ryan Dahl (often mistakenly called Rian/Rihan) took the open-source V8 engine from Chrome and embedded it inside a C program.
Why C?
Because C programs can directly interact with your machineâ€™s operating system and hardware.

So now:
The V8 engine executes JavaScript.
The C program allows it to run outside the browser.
This combination became Node.js, and just like V8, Node.js itself is also open source â€” meaning its code is publicly available and developers worldwide contribute to its improvement.

ğŸ’¡ So, What is Node.js?
Node.js is not a framework.
Node.js is not a library.
Node.js is a runtime environment that allows you to execute JavaScript code outside of the browser.

In simple words:
ğŸ‘‰ Node.js = Chromeâ€™s V8 engine embedded inside a C program, giving us the ability to run JavaScript anywhere.
âš¡ Thatâ€™s why you can now build servers, APIs, command-line tools, and even desktop apps using JavaScript with Node.js.
*/

/*
Difference Between JavaScript in Browser and Node.js

When you write JavaScript code in the browser, you can use features like alert, document, window, fetch, setTimeout, etc. But not all of these are part of JavaScript itselfâ€”many of them are Web APIs provided by the browser. For example, alert is not part of core JavaScript, it is a browser-provided functionality that displays a UI message. However, if you try running the same alert in Node.js, youâ€™ll get an error because Node.js runs in a command-line environment without a window, UI, or browser APIs.
Node.js only supports core JavaScript and provides its own additional modules like File System (fs), Crypto, etc. It reimplements only the APIs that make sense outside of a browser, such as setTimeout and setInterval, but not browser-specific ones like alert or document.getElementById.

ğŸ‘‰ In summary:
Browser JavaScript = Core JS + Browser APIs (DOM, alert, fetch, window, document).
Node.js JavaScript = Core JS + Node.js APIs (fs, crypto, CLI utilities).
Both environments run JavaScript, but the APIs available depend on the runtime environment.

ğŸ‘‰ In Short:
JavaScript in the browser has access to Web APIs like alert, document, and fetch provided by the browser, while Node.js runs JavaScript in a command-line environment with its own APIs like fs and crypto. Both run JavaScript, but the available APIs depend on the runtime.
*/

/* 
Q -> Understanding Node.js Modules and Their Role in Structuring Code

ğŸ”¹ What are Modules in Node.js?

Modules are used to organize and reuse code.
They allow us to split code into smaller, manageable files.

Types of modules:
Built-in modules â†’ provided by Node.js (e.g., fs, http).
Third-party modules â†’ installed via npm (e.g., express).
Custom modules â†’ created by you (e.g., math.js).

ğŸ”¹ How to Use Modules?
Use require() to load modules.
const fs = require("fs"); // Built-in module
const math = require("./math.js"); // Custom module
require("fs") â†’ loads Node.js built-in file system module.
require("./math.js") â†’ loads your own custom file.

ğŸ”¹ How Node.js Handles require
First checks third-party modules (from node_modules).
Then checks built-in modules.
Finally checks custom modules (paths like ./ or ../).

ğŸ”¹ Behind the Scenes (Module Wrapper)
Node.js wraps every module inside a function:
(function(exports, require, module, __filename, __dirname) {
   // your code here
});


This gives access to:
require â†’ load modules
exports / module.exports â†’ share code
__filename â†’ current file path
__dirname â†’ current directory path

ğŸ”¹ Module Caching
Once a module is loaded, Node.js caches it.
Next time you require() it, Node.js uses the cached version â†’ improves performance.

âœ… Key Takeaway:
In browsers â†’ JS runs with Web APIs (alert, document, window).
In Node.js â†’ JS runs with Node APIs (fs, crypto, http).
Modules make Node.js powerful and flexible for building apps.

*/

/*
npm (Node Package Manager) is used to manage packages in Node.js projects. Although â€œNode Package Managerâ€ is not an official full form, it makes sense since npm is responsible for handling external libraries and dependencies. To start using npm in a project, you need a package.json file at the root of your project. This file acts as a configuration/manifest and contains details like project name, version, entry point, scripts, and most importantly, dependencies. You can create it by running npm init, which asks for basic information and generates the file. Dependencies are added when you install external packages using npm install <package-name>, and the installed source code is stored inside the node_modules folder. You should never push node_modules to GitHub because it is bulkyâ€”your collaborators can regenerate it by running npm install, which fetches all dependencies listed in package.json. Alongside, npm also creates a package-lock.json file, which records the exact versions of dependencies and even the dependencies of dependencies. This ensures consistency across different environments. In short, package.json defines your projectâ€™s dependencies, node_modules contains the actual code, and package-lock.json ensures version integrity.

â¸»

*/  
 
  /* 
ğŸ“˜ Notes: Node.js File System (FS) Module
 
ğŸ”¹ Importing the FS Module
  â€¢	In older Node.js versions:
  const fs = require("fs");
 
  â€¢	In newer Node.js versions (preferred):
  const fs = require("node:fs");

  â€¢	âœ… Why node:fs?
  â€¢	Explicitly tells Node.js that this is a built-in module.
  â€¢	Prevents conflicts if a third-party package has the same name.
    â€¢	Convention:
    â€¢	node:moduleName â†’ built-in module
    â€¢ "package-name" â†’ external module
    â€¢ "./moduleName" â†’ custom module or internal module 

    const fs = require("node:fs");

  ğŸ”¹ Reading Files
  // Blocking (synchronous) read
  const contents = fs.readFileSync("notes.txt", "utf8");
  console.log(contents);

  â€¢	readFileSync â†’ blocking (synchronous).
  â€¢	readFile â†’ non-blocking (asynchronous).
  
  ğŸ”¹ Writing Files
  fs.writeFileSync("copy.txt", "Hello World!", "utf8");
  â€¢	Creates a new file (or overwrites if it already exists).
  â€¢	Overwrites content by default.

  ğŸ”¹ Appending to Files
  fs.appendFileSync("copy.txt", "
New content added", "utf8");
  â€¢	Adds new content without overwriting.
  â€¢	
 is used for new lines.

  ğŸ”¹ Copy File Contents
   const data = fs.readFileSync("notes.txt", "utf8");
   fs.writeFileSync("copy.txt", data, "utf8");
   â€¢	Reads from notes.txt and writes to copy.txt.

  ğŸ”¹ Creating Directories
  fs.mkdirSync("games"); // creates "games" folder

  fs.mkdirSync("games/xyz/a", { recursive: true });
  // creates nested folders automatically

  ğŸ”¹ Removing Directories
  fs.rmdirSync("games/a");
  fs.rmdirSync("games/xyz");
  fs.rmdirSync("games");

  ğŸ”¹ Deleting Files
  fs.unlinkSync("copy.txt");
  â€¢	Deletes the given file permanently.

  ğŸ”¹ Summary of FS Functions

  Function                     Description
  readFileSync()               Reads file (blocking)
  writeFileSync()              Creates/writes file (overwrites)
  appendFileSync()             Appends data to file
  mkdirSync()                  Creates a directory
  rmdirSync()                  Removes a directory (must be empty)
  unlinkSync()                 Deletes a file


  ğŸ”¹ Key Takeaways
  â€¢	Use require("node:fs") â†’ recommended for built-in modules.
  â€¢	Sync methods (xxxSync) block the execution until complete.
  â€¢	Async methods are non-blocking and should be preferred in production.
  â€¢	FS module allows full file and directory management in Node.js (CRUD operations).
*/
 Hello